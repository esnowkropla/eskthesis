\documentclass{article}
\usepackage{amsmath, url, listings, graphicx}
\title{Adiabatic Quantum Computation}
\author{Elliot Snow-Kropla\\Kyriakidis Group}
%\date{20 July 2012}

\lstset{ %
	tabsize = 2,
	frame = single,
	basicstyle = \ttfamily,
	escapebegin = <\>
}

\begin{document}
\maketitle
The most straightforward way to make an AQC circuit for a one-way function is to take advantage of the fact that out computations are reversible; thus we just make a circuit for computing the function going the easy way.

\section{Introduction}
Computers are very useful (duh).  But some computational problems are impractical to solve on classical computers.
Peter Shor\cite{shor} showed that a quantum computer could factor integers and calculate the discrete logarithm faster
than a classical computer could.  So the question becomes, how do we build a quantum computer?  Most quantum computer proposals
revolve around constructing quantum gates (in analogy with classical logical gates) to manipulate quantum states, but this is
hard.  The more qubits you add the harder it is to shield your computer from the outside world, so you get more decoherence.  You
add more qubits to counter-act decoherence ...  So what I've looked at is an alternative approach to building a quantum computer
based around adiabatic annealing.

\section{Background}

\subsection{Classical Computing}

\subsection{Quantum Computing}

\subsection{Adiabatic Quantum Computing}

\section{Quantum Circuit Compilation}
We need a way of generating Hamiltonians to solve the problems we are trying to solve.  In general, creating a Hamiltonian to solve
any given problem \emph{ex nihilo} is NP-Hard.  We can build up problem Hamiltonians out of the Hamiltonians of smaller sub-problems.\cite{gluing}

Given this, if we can find a Hamiltonian which is universal for computation, we can build up any arbitrary Hamiltonian we need.  The logical
{\tt NAND} is universal for computation, so if we can encode that we can encode any problem.

But can we encode problems in such a way that we can solve them faster than classically?

And then the bit about reversibility goes here


\subsection{Quantum Circuit}


\subsection{QSM Language}

\subsection{Embedding}
Because in general programs compiled to Ising graphs can be of any shape, we need a way to convert arbitrary graphs into Chimera graphs that can be executed on a machine.

\emph{ Embedding algorithm}


\section{Results and Discussion}

\subsection{Embedded Satisfiability}

We have carried out experiments on the Vesuvius hardware configured to evaluate random 3-SAT instances.  These were generated by randomly creating 3-SAT instances and then embedding them onto a Vesuvius chimera graph.  Because of the different embedding efficiencies, the final embedded graphs range in size from FIXME to FIXME.  

\subsection{Hamiltonian Scaling}

In order to isolate the effect that Hamiltonian size has on solution fidelity, machine runs were carried out on simple problem instances and scaled across the machine (where a simple problem is one that fits into a single qubyte).  So the top left qubyte on the machine was programmed with computational couplings, while each other qubyte was merely slaved/copied off of the origin.  Thus the computational difficulty was the same across all runs, so any differences are purely a result of the effects of using more spins and/or chain induced defects.

\subsection{The Model Part}

\section{Conclusion}

\begin{lstlisting}
def modular_power(b, e, m):
	r = 1
	while e > 0:
		if (e % 2) == 1:
			r = (r * b) % m
		e = e >> 1
		b = (b * b) % m
	return r
\end{lstlisting}

\bibliography{mybib}{}
\bibliographystyle{plain}
\end{document}
