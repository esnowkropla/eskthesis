\documentclass{article}
\usepackage{amsmath, url, listings, graphicx}
\title{Adiabatic Quantum Computation}
\author{Elliot Snow-Kropla\\Kyriakidis Group}
%\date{20 July 2012}

\lstset{ %
	tabsize = 2,
	frame = single,
	basicstyle = \ttfamily,
	escapebegin = <\>
}

\begin{document}
\maketitle
The most straightforward way to make an AQC circuit for a one-way function is to take advantage of the fact that out computations are reversible; thus we just make a circuit for computing the function going the easy way.

\section{Introduction}
Computers are very useful (duh).  But some computational problems are impractical to solve on classical computers.
Peter Shor\cite{shor} showed that a quantum computer could factor integers and calculate the discrete logarithm faster
than a classical computer could.  So the question becomes, how do we build a quantum computer?  Most quantum computer proposals
revolve around constructing quantum gates (in analogy with classical logical gates) to manipulate quantum states, but this is
hard.  The more qubits you add the harder it is to shield your computer from the outside world, so you get more decoherence.  You
add more qubits to counter-act decoherence ...  So what I've looked at is an alternative approach to building a quantum computer
based around adiabatic annealing.

\section{Background}

\subsection{Classical Computing}

\subsection{Quantum Computing}

\subsection{Adiabatic Quantum Computing}

\section{Quantum Circuit Compilation}
We need a way of generating Hamiltonians to solve the problems we are trying to solve.  In general, creating a Hamiltonian to solve
any given problem \emph{ex nihilo} is NP-Hard.  We can build up problem Hamiltonians out of the Hamiltonians of smaller sub-problems.\cite{mccurdy}

Given this, if we can find a Hamiltonian which is universal for computation, we can build up any arbitrary Hamiltonian we need.  The logical
{\tt NAND} is universal for computation, so if we can encode that we can encode any problem.

\subsection{QSM Language}

\subsection{Quantum Circuit}

\subsection{Embedding}

\begin{lstlisting}
def modular_power(b, e, m):
	r = 1
	while e > 0:
		if (e % 2) == 1:
			r = (r * b) % m
		e = e >> 1
		b = (b * b) % m
	return r
\end{lstlisting}

\bibliography{mybib}{}
\bibliographystyle{plain}
\end{document}
