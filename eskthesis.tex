\documentclass[12pt]{dalthesis}
\usepackage{amsmath}

\begin{document}

\title{Adiabatic Quantum Computation}
\author{Elliot Snow-Kropla}
%\date{20 July 2012}

\degree{Master of Science}
\degreeinitial{M.Sc.}
\faculty{Faculty of Science}
\dept{Department of Physics and Atmospheric Science}

\defencemonth{August}\defenceyear{2014}

\frontmatter

\begin{abstract}
	Lorum Ipsum
\end{abstract}

\begin{acknowledgements}
	Nobody! Hahaha
\end{acknowledgements}

\mainmatter

\chapter{Introduction}

\chapter{Adiabatic Quantum Computing}
Introduced by Farhi et.\ al.\cite{farhi}, the idea of adiabatic quantum computation (hereafter AQC) is to exploit the adiabatic theorem to solve computational problems.  There are two main components to the idea.  First, we find a Hamiltonian such that the ground state is the solution to a computational problem (e.g. a bitstring of spins pointed up and down).  Second, we use the adiabatic theorem to move from some easily prepared initial state into the Hamiltonian we found.

\section{Finding a Problem Hamiltonian}
While in principle there are an unlimited number of ways to construct a Hamiltonian whose ground state encodes the solution to a computation, our method is to use an N-particle Hamiltonian of the form

\begin{displaymath}
	H = \sum_{i} h_i \sigma_i^Z + \sum_{i < j} J_{ij} \sigma_i^Z\sigma_j^Z
\end{displaymath}

where $\sigma_i^Z$ is the pauli matrix of the ith particle and $h_i$ and $J_{ij}$ are the parameters of the Hamiltonian.  This 2-local Hamiltonian corresponds to a graph structure, where each particle is a vertex and each non-zero $J_{ij}$ is an edge, while non-zero $h_i$s can be represented as edges to a constant "field" spin.

\section{Adiabatic Evolution}

\chapter{Embedding}
Because in general programs compiled to Ising graphs can be of any shape, we need a way to convert arbitrary graphs into Chimera graphs that can be executed on a machine.

\section{ Embedding algorithm}

The embedding algorithm is as follows:

\begin{enumerate}
	\item Designate the input graph $V$ and the destination Chimera graph $G$
	\item Label the spins in the input graph $V_i$
	\item Designate the cloning map from a given logical spin to its set of clones $G_i \mapsto [G_0 \ldots G_n] $ Initially, the
		clone list will contain only the parent logical spin
	\item Assign each spin $V_i$ to a spin in the left side of a $K_{4,4}$ that lies along the diagonal of $G$
	\item For each edge $V_{i,j}$ in $V$, iterate pairwise through the clone sets of $G_i,G_j$ until we find the pair $G_x,G_y$ such that
		the path from $G_x$ to $G_y$ is minimal
	\item Divide the spins in the path into two groups at the first kink in the path: assign all the spins in one group to 
\end{enumerate}

\chapter{Preliminary Results}

Figure FIXME shows the results of 50,000 runs of the annealing machine consisting of 1000 runs at various annealing times.  Along the y-axis is the fidelity, and along the x-axis is the annealing time.  Contrary to what we expect from the adiabatic theorem and simulations of quantum annealing the fidelity is uncorrelated with annealing from 20$\mu$s out to roughly 500$ \mu$s, after which the fidelity \emph{decreases} with increasing annealing time.  This unexpected behaviour leaves us with a number of questions:

\begin{itemize}
	\item For long annealing times, why does the fidelity decrease with increasing annealing times?
	\item For short annealing times, why does the fidelity appear insensitive to annealing time?
	\item Is the short time fidelity dominated by the Hamiltonian programming noise?
	\item Is there significant drift in the fidelities after programming?
	\item Does the Hamiltonian fidelity depend strongly on the number of coupling values?
\end{itemize}

\bibliographystyle{plain}
\bibliography{eskthesis}
\end{document}
