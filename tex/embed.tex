\chapter{Embedding}
\section{Creating Problem Hamiltonians}
Embedding is the name we give to the general process of translating a computational problem into something which is ready for an adiabatic quantum computer to evaluate.  As mentioned in Section \ref{sec:prob_ham}, the first step is to generate a problem Hamiltonian.  We employ two methods for finding suitable problem Hamiltonians.  The first, using linear programming, is suitable for small Hamiltonians (generally only a few variables in size).  The second is to use the software \texttt{QCC} which takes advantage of the gluing theorem to stitch together a problem Hamiltonian out of smaller sub-Hamiltonians.
The second step in the embedding process is to translate our problem Hamiltonians, which generally may have arbitrary topologies, coupling values, number of variables etc. into Hamiltonians which an adiabatic quantum computer is capable of physically implementing.

These are not the only methods of generating problem Hamiltonians.  The programmatic style described above seems natural for solving actual computational problems, but e.g. if one wanted to go a more academic computer science route one could reduce one's problems to known NP-Complete problems and evaluate those.  Lucas \cite{lucas} handily provides a compilation of ising formulations of a variety of different NP-Complete suitable for such an approach.

\section{Linear Programming}
The requirements we have for a problem Hamiltonian can be described using a system of constraints, and solved using the techniques of linear programming (LP).
Briefly, LP is a method to optimize some objective function subject to linear equality and linear inequality constraints i.e. constraints of the form $ax + by < c$ (thus the name \emph{linear} programming).  There are many software packages that implement LP solving, both Free Software and proprietary.  This makes it an easily usable technique.

The way in which we use LP to create a problem Hamiltonian is to set our objective function to the sum of the value of the couplings in the Hamiltonian; for a complete graph we have $N = \frac{1}{2}n(n-1) + n$ fields and couplings, so our objective function will be of the form $\sum_{i=0}^N x_i$ where each $x_i$ is the value of either a field or coupling.

We then create a constraint for each possible state of the system; for states which satisfy the logic we wish to encode, we add a constraint such that 

\begin{equation}
	\sum_i^n s_i x_i + \sum_{i=n,j > i}^N s_i s_j x_i + K = 0
	\label{eq:LP}
\end{equation} 

where $s_i$ is the value of spin $i$ ($\pm 1$) in the state we are encoding and $K$ is a constant which will take on the value of the ground state energy.  The first sum in the constraint adds the energy contributions from the fields, while the second sum adds the energy contributions from the couplings.
For each state which does NOT satisfy the logic that we wish to encode, we add a constraint of the same form as Equation \ref{eq:LP} except that the total sum must be \emph{greater} than zero rather than equal to zero.

The combined effect of all of these constraints is that when we solve the system for the set of variables $x_i$ which minimize the objective function, states which encode the desired logic will have an energy of $-K$ and states which do not encode the desired logic will have an energy greater than $-K$.
This is a slightly unusual use for LP; normally the finding the set of $x_i$'s that optimize the objective function is the goal, but for us finding the $x_i$'s which satisfy the constraints if the central objective.
Minimizing the sum of the coupling values simply helps to keep the number of different coupling values small and the spread between them down.  This will be important because physical adiabatic quantum computers can only implement a finite number of different coupling values in finite ranges. 

Unfortunately while this method allows us to find a set of couplings to encode the logic of any circuit, we require a constraint for each possible state of each of the variables.  For a binary circuit with $n$ variables, this is $2^n$ states.
The above process for creating problem Hamiltonians is thus clearly exponentially hard, and becomes extremely computationally inefficient for larger circuit sizes.
That said, this method retains utility for finding small sub-Hamiltonians to use as building blocks for larger problem Hamiltonians using \texttt{QCC} as described in the next section.

\section{\texttt{QCC}}
\texttt{QCC} is a collection of programs and libraries designed to produce problem Hamiltonians.  The core of \texttt{QCC} are two pieces: the \texttt{QSM} language and interpreter, and the embedding algorithm.  The \texttt{QSM} language is a programming language designed to simplify the connecting of sub-Hamiltonians.  It is both human writable and serves as a compilation target for more complicated or high level languages.  One can write a \texttt{QSM} file describing a circuit composed of multiple sub-Hamiltonians, and the \texttt{QSM} interpreter will construct the appropriate problem Hamiltonian, including any auxiliary spins that the sub-Hamiltonians need if any.  Once the problem Hamiltonian has been generated, a Hamiltonian with equivalent ground states that is isomorphic to a sub-graph of a particular hardware implementation must be created in order for the problem Hamiltonian to be solved; this is the job of the embedding algorithm.

\section{\texttt{QSM} Language}
The \texttt{QSM} language is a simple language designed to be readable and writable by both humans and machines.  A \texttt{QSM} file consists of one or more \texttt{QSM} statements; each \texttt{QSM} statement is enclosed by parentheses and consists of a whitespace separated list of the statement components.  If a component has multiple sub-parts then they are also enclosed in parentheses.  There are two kinds of \texttt{QSM} statements, gate statements and clamp statements.

A typical \texttt{QSM} gate statement consists of three components: first the name of the gate or sub-Hamiltonian to be included, then a parenthesis-enclosed list of the input spins for the gate, and third a parenthesis-enclosed list of the output spins for the gate.  An example \texttt{QSM} gate statement is: 
\begin{center}
	\texttt{(and (a b) (c))}
\end{center}
This \texttt{QSM} statement encodes the logic $A \wedge B = C$.  A variable name may be prefixed by a $\sim$, in which case the logic of that variable is negated.  The other type of \texttt{QSM} statement besides a gate statement is the clamp statement; this statement consists of two components.  First the keyword \texttt{clamp}, followed by a list of variables and the values that they are to be clamped to.  A clamp statement looks like
\begin{center}
	\texttt{(clamp ((a +1) (b -1)))}
\end{center}
The above clamp statement sets the value of the variables \texttt{a} and \texttt{b} to +1 and -1, respectively.

A complete \texttt{QSM} file might then look like

\begin{center}
	\texttt{(and (a $\sim$b) (c))}\\
	\texttt{(or (x y) (b))}\\
	\texttt{(clamp ((c +1)))}
\end{center}
which would compile to a Hamiltonian which encodes the logic $a \wedge \neg b = c, x \vee y = b, c = \text{TRUE}$ and the resulting ground states will be those states for which the logic is satisfied.

The graph representation of the above Hamiltonian is a four vertex graph consisting of a K3 with an extra vertex connected to one of vertices in the K3.  Such a graph is not directly implementable on the \texttt{VESUVIUS} machine due to its connectivity, and so before evaluating it we would need to \emph{embed} it.

\section{Embedding algorithm}
\label{sec:embed_algo}
Once we have our problem Hamiltonians we need to convert them into Hamiltonians which have the same structure as the Chimera graph that the \texttt{VESUVIUS} machine has.  This is done by adding \emph{clone spins} into the graph: each clone spin has the same value in the ground state as one of the logical spins in the input graph.  
Thus we can decrease the connectivity of the input graph until it is sparse enough to be isomorphic to a physical machine.  The following algorithm is essentially equivalent to one presented in \cite{choi1}.
We expect that translating complete graphs onto graphs with constant neighbour counts to require roughly a quadratic size penalty in the number of clone spins (as the number of connections in a complete graph $\sim n^2$).
Ideally, to ensure that each clone spin's ground state is the same as it's parent we would have $J_{ij} << J_{clone} \forall i,j$.  Because of physical limits of the machine (especially the resolution mentioned above) large values of $J_{clone}$ may not maximize fidelity: for a machine with finite resolution, having a large $J_{clone}$ may compress other coupling values together such that the ground state starts to overlap with higher energy state.  On the other hand a too small value of $J_{clone}$ may result in ground states in which the clones are not aligned, which will almost certainly also produce incorrect ground states. Thus we have to find an empirical value of $J_{clone}$ that maximizes the fidelity while preserving the ground states.

The embedding algorithm is as follows:

\emph{\textbf{Definitions:}}

Designate the input Hamiltonian graph $V$ and the output Chimera graph $G$.  Label the spins in $V$ and $G$ as $V_i$ and $G_i$ respectively.
We define the \emph{clone map} $C_i$ as the set of spins $[i,j \ldots]$ which have the same logical value as their parent spin: so for example the clone map of spin 5, $C_5$, might be $[2,3,13]$ which would mean that spins 2, 3, 5 and 13 all share the same logical value.  
We define a mapping $M$ between logical spins in graph $V$ and computation spins in graph $G$.  That is, spin $V_{12}$ representing the 12th variable in a SAT problem might be mapped to $G_{187}$, the 187th machine spin.

We also define a \emph{clone coupling} value which is as large as possible and ferromagnetic; this attempts to ensure that all the members of a clone map are aligned in the ground state.  In the final $G$, each member of a clone map should have a clone coupling connecting it to at least one other member of the clone map.

\emph{\textbf{Procedure:}}
\begin{enumerate}
	\item Populate $M$ by mapping each $V_i$ to one of the spins $G_j$ on the left side of a qubyte that lies along the diagonal of $G$
	\item For each field term in $V$, add a field to $G$ on the corresponding spin
	\item For each $J_{ij}$ in $V$, conduct the following operation:
		\begin{itemize}
			\item Scan through both of $C_i$ and $C_j$ to find the pair which are nearest to each other in $G$; call these $x$ and $y$
			\item Get a list of each spin that lies along the path between $x$ and $y$
			\item Assign half of these spins to $C_i$ and half to $C_j$; add the appropriate clone coupling into $G$ for each spin in the path to ensure that the clone map is properly connected
			\item Finally, at the interface between the two new clone map members, add a coupling into $G$ with the same value as $J_{ij}$
		\end{itemize}
\end{enumerate}

Each term in $V$, both fields and couplings, should now have a corresponding term in $G$.  $G$ should also contain many coupling terms that group the necessary clone maps.  Figure \ref{fig:embedding} shows an example of the embedding process.


\begin{figure}
	%\scalebox{}{
	%	\includegraphics[]{}
	%}
	\caption[Embedding Algorithm]{This figure shows three steps of the embedding algorithm: mapping spins from $V$ to $G$, tracing the path for the clones between $V_i$ and $G_j$ and partitioning the path into $C_i$ and $C_j$.}
	\label{fig:embedding}
\end{figure}

This algorithm is tailored AQC machines whose qubits are arranged in a square shape (specifically the Chimera graph), however, the principle should be generalizable: as mentioned above any reasonably compact graph with constant connectivity should be able to embed a complete graph with an $n^2$ overhead by allocating the input graph spins along the diagonal.
